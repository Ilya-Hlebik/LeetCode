| LeetCode Task                                                                                                          | Solution                                                                                                                                                                                                                                                                                                                      |
|------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [241. Different Ways to Add Parentheses](https://leetcode.com/problems/different-ways-to-add-parentheses/description/) | Each operator (+, -, *) splits the expression into left and right parts. Recursively compute all results for both sides, then combine every left and right result using that operator. Default case - just add expression parsed to int                                                                                       |
| [257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/)                                             | Keep building a path string as you go down: "1->2->5" etc. When you move to left or riht, pass a new string with the updated path (so each branch keeps its own copy). If the current node doesn't have left/right, add the built string to the result.                                                                       |
| [258. Add Digits](https://leetcode.com/problems/add-digits/description/)                                               | If the result is less than 10, return it (single-digit reached). Sum all digits of the number. Take the sum and repeat the process recursively.                                                                                                                                                                               |
| [260. Single Number III](https://leetcode.com/problems/single-number-iii/description/)                                 | XOR all elements. After this, find the lowest set bit using xor & (-xor), and divide the numbers into two groups: those with this bit set and those without it. The first group will be arr0, and the second will be arr1.                                                                                                    |
| [263. Ugly Number](https://leetcode.com/problems/ugly-number/description/)                                             | Keep dividing n by 2, then 3, then 5 as long as you can. If after all divisions the number becomes 1, it’s ugly. If you end up with anything else, it’s not.                                                                                                                                                                  |
| [264. Ugly Number II](https://leetcode.com/problems/ugly-number-ii/description/)                                       | Keep a list of ugly numbers starting from 1. Use three pointers (for ×2, ×3, ×5) to track which base number to multiply next. Each step, take the smallest among those three products, add it to the list, and advance any pointer(s) that produced that number.                                                              |
| [273. Integer to English Words](https://leetcode.com/problems/integer-to-english-words/description/)                   | Use arrays for numbers (1–19), tens (20, 30, ...), big units (1,000; 1,000,000; ...), and for 100. Divide by 1,000 in each cycle iteration. Concatenate the beginning numbers with “hundred,” then add tens/middle numbers, and finally append the number plus the corresponding big unit big[i], where i is the cycle index. |
| [275. H-Index II](https://leetcode.com/problems/h-index-ii/description/)                                               | Binary search. If midval >= length-mid - response = length - mid and go left                                                                                                                                                                                                                                                  |
| [278. First Bad Version](https://leetcode.com/problems/first-bad-version/description/)                                 | Use binary search. If the version is bad, record the result and move left.                                                                                                                                                                                                                                                    |
| [279. Perfect Squares](https://leetcode.com/problems/perfect-squares/)                                                 | Use DP where memo[i] stores the minimum number of perfect squares that sum to i. For each number i (except 0. It's already equal 0), try all square numbers j*j ≤ i and pick the best (1+ memo[i-(j*j)]). Build up from 0 to n, and the final answer is memo[n].                                                              |
| [282. Expression Add Operators](https://leetcode.com/problems/expression-add-operators/description/)                                                      | Use DFS (backtracking) to try every way of inserting +, -, and * between the digits. As you build the expression, keep track of where you are in the string (pos), what the expression looks like so far (current), the value it evaluates to (currentTotal), and the last number you used (lastOperand). When you reach the end of the string, if the total equals the target, you save the expression. At each step, you take a substring starting from pos to make the next number, but you have to avoid leading zeros (so if a number starts with 0, it can only be exactly "0"). For the very first number you just start the expression. After that, you try three options: add the number, subtract it, or multiply it. For multiplication, you “undo” the last number in the total and replace it with the multiplied value so that precedence works correctly. This process explores all possible valid expressions.                                                                         |

