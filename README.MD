| LeetCode Task                                                                                                         | Solution                                                                                                                                                                                                                                                                                                                      |
|-----------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [241. Different Ways to Add Parentheses](https://leetcode.com/problems/different-ways-to-add-parentheses/description/) | Each operator (+, -, *) splits the expression into left and right parts. Recursively compute all results for both sides, then combine every left and right result using that operator. Default case - just add expression parsed to int                                                                                       |
| [257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/)                                            | Keep building a path string as you go down: "1->2->5" etc. When you move to left or riht, pass a new string with the updated path (so each branch keeps its own copy). If the current node doesn't have left/right, add the built string to the result.                                                                       |
| [258. Add Digits](https://leetcode.com/problems/add-digits/description/)                                              | If the result is less than 10, return it (single-digit reached). Sum all digits of the number. Take the sum and repeat the process recursively.                                                                                                                                                                               |
| [260. Single Number III](https://leetcode.com/problems/single-number-iii/description/)                                | XOR all elements. After this, find the lowest set bit using xor & (-xor), and divide the numbers into two groups: those with this bit set and those without it. The first group will be arr0, and the second will be arr1.                                                                                                    |
| [263. Ugly Number](https://leetcode.com/problems/ugly-number/description/)                                            | Keep dividing n by 2, then 3, then 5 as long as you can. If after all divisions the number becomes 1, it’s ugly. If you end up with anything else, it’s not.                                                                                                                                                                  |
| [264. Ugly Number II](https://leetcode.com/problems/ugly-number-ii/description/)                                            | Keep a list of ugly numbers starting from 1. Use three pointers (for ×2, ×3, ×5) to track which base number to multiply next. Each step, take the smallest among those three products, add it to the list, and advance any pointer(s) that produced that number.                                                              |
| [273. Integer to English Words](https://leetcode.com/problems/integer-to-english-words/description/) | Use arrays for numbers (1–19), tens (20, 30, ...), big units (1,000; 1,000,000; ...), and for 100. Divide by 1,000 in each cycle iteration. Concatenate the beginning numbers with “hundred,” then add tens/middle numbers, and finally append the number plus the corresponding big unit big[i], where i is the cycle index. |
| [275. H-Index II](https://leetcode.com/problems/h-index-ii/description/)  | Binary search. If midval >= length-mid - response = length - mid and go left                                                                                                                                                                                                                                                  |
| [278. First Bad Version](https://leetcode.com/problems/first-bad-version/description/)  | Use binary search. If the version is bad, record the result and move left.                                                                                                                                                                                                                                                                   |

